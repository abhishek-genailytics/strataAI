<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StrataAI Unified API Tester</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        font-weight: 700;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .content {
        padding: 30px;
      }

      .config-section {
        background: #f8fafc;
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 30px;
        border: 2px solid #e2e8f0;
      }

      .config-section h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3rem;
        display: flex;
        align-items: center;
      }

      .config-section h3::before {
        content: "‚öôÔ∏è";
        margin-right: 10px;
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #4a5568;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.2s ease;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .model-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .model-option {
        background: white;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        padding: 15px;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
      }

      .model-option:hover {
        border-color: #667eea;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .model-option.selected {
        border-color: #667eea;
        background: #f0f4ff;
      }

      .model-option input[type="radio"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }

      .model-name {
        font-weight: 600;
        color: #2d3748;
        margin-bottom: 5px;
      }

      .model-provider {
        font-size: 0.9rem;
        color: #718096;
      }

      .test-section {
        background: #fff;
        border-radius: 12px;
        padding: 25px;
        border: 2px solid #e2e8f0;
      }

      .test-section h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3rem;
        display: flex;
        align-items: center;
      }

      .test-section h3::before {
        content: "üß™";
        margin-right: 10px;
      }

      .button-group {
        display: flex;
        gap: 15px;
        margin-top: 20px;
      }

      button {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #4a5568;
      }

      .btn-secondary:hover {
        background: #cbd5e0;
      }

      .btn-stream {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        color: white;
      }

      .btn-stream:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
      }

      .response-section {
        margin-top: 30px;
        padding: 25px;
        background: #f8fafc;
        border-radius: 12px;
        border: 2px solid #e2e8f0;
      }

      .response-section h4 {
        color: #2d3748;
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .response-content {
        background: #2d3748;
        color: #e2e8f0;
        padding: 20px;
        border-radius: 8px;
        font-family: "Monaco", "Menlo", monospace;
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
      }

      .loading {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #667eea;
        font-weight: 600;
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #e2e8f0;
        border-top: 2px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .error {
        color: #e53e3e;
        background: #fed7d7;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #feb2b2;
      }

      .success {
        color: #38a169;
        background: #c6f6d5;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #9ae6b4;
      }

      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-online {
        background: #48bb78;
      }

      .status-offline {
        background: #e53e3e;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ StrataAI Unified API Tester</h1>
        <p>
          Test your unified API gateway with multiple providers using a single
          PAT token
        </p>
      </div>

      <div class="content">
        <!-- Configuration Section -->
        <div class="config-section">
          <h3>Configuration</h3>

          <div class="form-group">
            <label for="apiUrl">API Base URL:</label>
            <input
              type="text"
              id="apiUrl"
              value="http://localhost:8000/api/v1"
              placeholder="http://localhost:8000/api/v1"
            />
          </div>

          <div class="form-group">
            <label for="patToken">Strata PAT Token:</label>
            <input
              type="password"
              id="patToken"
              placeholder="Enter your Personal Access Token"
              value="pat_cPvHpcv2UAjdQktFmN6tIStnAYkU1QRkJAj20I4wH-k"
              required
            />
          </div>

          <div class="form-group">
            <label>Select Model:</label>
            <div class="model-grid">
              <div
                class="model-option"
                onclick="selectModel('openai/gpt-3.5-turbo', this)"
              >
                <input type="radio" name="model" value="openai/gpt-3.5-turbo" />
                <div class="model-name">GPT-3.5 Turbo</div>
                <div class="model-provider">OpenAI</div>
              </div>
              <div
                class="model-option"
                onclick="selectModel('openai/gpt-4', this)"
              >
                <input type="radio" name="model" value="openai/gpt-4" />
                <div class="model-name">GPT-4</div>
                <div class="model-provider">OpenAI</div>
              </div>
              <div
                class="model-option"
                onclick="selectModel('anthropic/claude-3-haiku-20240307', this)"
              >
                <input
                  type="radio"
                  name="model"
                  value="anthropic/claude-3-haiku-20240307"
                />
                <div class="model-name">Claude 3 Haiku</div>
                <div class="model-provider">Anthropic</div>
              </div>
              <div
                class="model-option"
                onclick="selectModel('anthropic/claude-3-sonnet-20240229', this)"
              >
                <input
                  type="radio"
                  name="model"
                  value="anthropic/claude-3-sonnet-20240229"
                />
                <div class="model-name">Claude 3 Sonnet</div>
                <div class="model-provider">Anthropic</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Test Section -->
        <div class="test-section">
          <h3>Test Chat Completion</h3>

          <div class="form-group">
            <label for="testMessage">Test Message:</label>
            <textarea
              id="testMessage"
              rows="3"
              placeholder="Enter your test message here..."
            >
Hello! Please respond with 'API working correctly via [provider name]' and tell me what model you are.</textarea
            >
          </div>

          <div class="button-group">
            <button class="btn-primary" onclick="testChatCompletion()">
              <span>üí¨</span> Send Message
            </button>
            <button class="btn-stream" onclick="testStreamingCompletion()">
              <span>üåä</span> Test Streaming
            </button>
            <button class="btn-secondary" onclick="testModelsEndpoint()">
              <span>üìã</span> List Models
            </button>
            <button class="btn-secondary" onclick="clearResponse()">
              <span>üóëÔ∏è</span> Clear
            </button>
          </div>
        </div>

        <!-- Response Section -->
        <div class="response-section">
          <h4>Response <span id="statusIndicator"></span></h4>
          <div id="responseContent" class="response-content">
            Ready to test! Configure your PAT token and select a model above.
          </div>
        </div>
      </div>
    </div>

    <script>
      let selectedModel = "";
      let isStreaming = false;

      function selectModel(model, element) {
        selectedModel = model;

        // Update UI
        document.querySelectorAll(".model-option").forEach((option) => {
          option.classList.remove("selected");
        });

        if (element) {
          element.classList.add("selected");
        }
        document.querySelector(`input[value="${model}"]`).checked = true;

        updateStatus(`Selected model: ${model}`, "info");
      }

      function updateStatus(message, type = "info") {
        const indicator = document.getElementById("statusIndicator");
        const content = document.getElementById("responseContent");

        const timestamp = new Date().toLocaleTimeString();
        const statusClass =
          type === "error" ? "status-offline" : "status-online";

        indicator.innerHTML = `<span class="status-indicator ${statusClass}"></span>${timestamp}`;

        if (type === "loading") {
          content.innerHTML = `<div class="loading"><div class="spinner"></div>${message}</div>`;
        } else {
          content.textContent = `[${timestamp}] ${message}`;
        }
      }

      function getHeaders() {
        const token = document.getElementById("patToken").value.trim();
        if (!token) {
          throw new Error("Please enter your Strata PAT token");
        }

        return {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        };
      }

      function getApiUrl() {
        return (
          document.getElementById("apiUrl").value.trim() ||
          "http://localhost:8000/api/v1"
        );
      }

      function getUnifiedApiUrl() {
        // The unified API endpoints are at the base API URL
        return (
          document.getElementById("apiUrl").value.trim() ||
          "http://localhost:8000/api/v1"
        );
      }

      async function testChatCompletion() {
        if (!selectedModel) {
          updateStatus("Please select a model first", "error");
          return;
        }

        const message = document.getElementById("testMessage").value.trim();
        if (!message) {
          updateStatus("Please enter a test message", "error");
          return;
        }

        try {
          updateStatus("Sending chat completion request...", "loading");

          const response = await fetch(
            `${getUnifiedApiUrl()}/chat/completions`,
            {
              method: "POST",
              headers: getHeaders(),
              body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: "user", content: message }],
                temperature: 0.7,
                max_tokens: 150,
              }),
            }
          );

          const data = await response.json();

          if (response.ok) {
            const result = {
              model: data.model,
              response: data.choices[0].message.content,
              usage: data.usage,
              id: data.id,
            };

            updateStatus(
              `‚úÖ SUCCESS!\n\nModel: ${result.model}\nResponse: ${
                result.response
              }\n\nUsage: ${JSON.stringify(
                result.usage,
                null,
                2
              )}\nRequest ID: ${result.id}`,
              "success"
            );
          } else {
            updateStatus(
              `‚ùå ERROR: ${response.status}\n\n${JSON.stringify(
                data,
                null,
                2
              )}`,
              "error"
            );
          }
        } catch (error) {
          updateStatus(`‚ùå NETWORK ERROR: ${error.message}`, "error");
        }
      }

      async function testStreamingCompletion() {
        if (!selectedModel) {
          updateStatus("Please select a model first", "error");
          return;
        }

        const message = document.getElementById("testMessage").value.trim();
        if (!message) {
          updateStatus("Please enter a test message", "error");
          return;
        }

        if (isStreaming) {
          updateStatus("Streaming request already in progress", "error");
          return;
        }

        try {
          isStreaming = true;
          updateStatus("Starting streaming chat completion...", "loading");

          const response = await fetch(
            `${getUnifiedApiUrl()}/chat/completions/stream`,
            {
              method: "POST",
              headers: getHeaders(),
              body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: "user", content: message }],
                stream: true,
                temperature: 0.7,
                max_tokens: 150,
              }),
            }
          );

          if (!response.ok) {
            const errorData = await response.json();
            updateStatus(
              `‚ùå STREAMING ERROR: ${response.status}\n\n${JSON.stringify(
                errorData,
                null,
                2
              )}`,
              "error"
            );
            return;
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let streamedContent = "";
          let buffer = "";

          updateStatus(`üåä STREAMING from ${selectedModel}:\n\n`, "success");

          while (true) {
            const { done, value } = await reader.read();

            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop(); // Keep incomplete line in buffer

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const data = line.slice(6);

                if (data.trim() === "[DONE]") {
                  const finalContent = `üåä STREAMING COMPLETE from ${selectedModel}:\n\n${streamedContent}\n\n‚úÖ Stream finished successfully!`;
                  document.getElementById("responseContent").textContent =
                    finalContent;
                  isStreaming = false;
                  return;
                }

                try {
                  const chunk = JSON.parse(data);
                  if (
                    chunk.choices &&
                    chunk.choices[0].delta &&
                    chunk.choices[0].delta.content
                  ) {
                    streamedContent += chunk.choices[0].delta.content;
                    const currentContent = `üåä STREAMING from ${selectedModel}:\n\n${streamedContent}`;
                    document.getElementById("responseContent").textContent =
                      currentContent;
                  }
                } catch (e) {
                  // Skip invalid JSON chunks
                }
              }
            }
          }
        } catch (error) {
          updateStatus(`‚ùå STREAMING ERROR: ${error.message}`, "error");
        } finally {
          isStreaming = false;
        }
      }

      async function testModelsEndpoint() {
        try {
          updateStatus("Fetching available models...", "loading");

          const response = await fetch(`${getUnifiedApiUrl()}/models`, {
            headers: getHeaders(),
          });

          const data = await response.json();

          if (response.ok) {
            const models = data.data
              .map((model) => `${model.id} (${model.owned_by})`)
              .join("\n");
            updateStatus(
              `üìã AVAILABLE MODELS:\n\n${models}\n\nTotal: ${data.data.length} models`,
              "success"
            );
          } else {
            updateStatus(
              `‚ùå ERROR: ${response.status}\n\n${JSON.stringify(
                data,
                null,
                2
              )}`,
              "error"
            );
          }
        } catch (error) {
          updateStatus(`‚ùå NETWORK ERROR: ${error.message}`, "error");
        }
      }

      function clearResponse() {
        document.getElementById("responseContent").textContent =
          "Response cleared. Ready for next test!";
        document.getElementById("statusIndicator").innerHTML = "";
      }

      // Initialize with first model selected
      window.addEventListener("load", () => {
        const firstModel = document.querySelector(".model-option");
        selectModel("openai/gpt-3.5-turbo", firstModel);
      });
    </script>
  </body>
</html>
